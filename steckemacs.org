#+Title: Steckemacs
#+Author: steckerhalter

* Options                                                  :noexport:ARCHIVE:
#+OPTIONS: todo:t html-style:nil
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="/css/style.css" />
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="/css/steckemacs.css" />
#+INFOJS_OPT: view:showall toc:t ftoc:t mouse:#555555 path:/js/org-info.js

#+BEGIN_SRC emacs-lisp :tangle no :results silent
(org-babel-tangle-file "steckemacs.org" "steckemacs.el" "emacs-lisp")
#+END_SRC


* Usage

*steckemacs* is an Emacs configuration that integrates around 60 modes (packages). Stock Emacs is not very usable and lacks many convenient commands. Over the years I've discovered many good extensions and added them to this setup. The goal is to keep everything in one file =steckemacs.org= (plus =.emacs= for the initialization) and not as many others to split it over lots of files and directories. Packages are built directly from source code using [[*Quelpa][quelpa]] (my homegrown tool for this purpose).

The source code is hosted on Github: [[https://github.com/steckerhalter/steckemacs]]

*To use this setup please use Emacs 24.3.50 or later (currently that's the development snapshot). Older versions don't work because I use some of the new features of what is to become Emacs 24.4*

** Installation

Change to a directory of your choice and clone *steckemacs*:

#+BEGIN_SRC shell-script
cd <my directory>
git clone https://github.com/steckerhalter/steckemacs.git
#+END_SRC

And symlink =.emacs= into your home directory:

#+BEGIN_SRC shell-script
cd ~
ln -s <path to the directory from above>/.emacs
#+END_SRC

That's it. Then you can run emacs and it should pick up the config, install all the packages and make you happy ;)

** How does it work?

I'm using *org-mode* to manage *steckemacs*. =.emacs= (sometimes called *init* file) loads =steckemacs.org=, exports all the code blocks (this process is called "tangling") to =steckemacs.el=. If a block is marked with =:tangle no= it will be skipped. When the tangling is finished =steckemacs.el= is loaded to initialize Emacs.

You can find more information about *Literate Programming* and *org-mode* here: http://orgmode.org/worg/org-contrib/babel/intro.html#literate-programming

The cool thing about this setup is that you can export the same file as documentation to HTML quite easily. Take a look at the [[https://github.com/steckerhalter/steckemacs/blob/master/Makefile][Makefile]] to see how this done with a script. To do it from Org mode directly press =C-c C-e=, choose =h= and then one of the options to produce HTML output.

** Keyboard shortcuts

By using the =key-chord= mode we can avoid having to type C- or M- all the time. It allows for using keys pressed simultaneously and I'm using it quite often.

When I write =fg= as a key combo it means you would have to press =f= and =g= at the same time.

I only describe my custom key combinations currently. To learn the standard Emacs commands, go through the Tutorial =C-h t=, use =C-h b= or =M-x= to see/filter the available commands/shortcuts.

#+NAME: keys-doc
#+BEGIN_SRC emacs-lisp :var keys=keys :tangle no :results output raw :exports results
(let* ((header (car keys))
       (keys (delq header keys))
       (category))
  (pop keys)
  (mapcar (lambda (l) (if (listp l)
                          (progn
                            (unless (string= (nth 1 l) category)
                              (setq category (nth 1 l))
                              (princ (format "*** %s\n" category))
                              (princ "#+ATTR_HTML: :rules all :cellpadding 4\n")
                              (princ "| / | <r> | | \n")
                              )
                            (princ (format "| # | =%s= | %s |\n" (car l) (nth 2 l))))
                        (princ "|-\n")))
          keys))
(princ "\n")
#+END_SRC

This table is generated with an Elisp block =keys-doc= from an Org table which is also used in the code [[*Key%20Bindings][further below]].

* Code

** Always maximize Emacs

#+BEGIN_SRC emacs-lisp
(modify-all-frames-parameters '((fullscreen . maximized)))
#+END_SRC

This will maximize the current and all future Emacs frames. The parameter has been added in Emacs 24.4

** Load Path

The variable =load-path= lists all the directories where Emacs should look for Elisp files. The first file found is used, therefore the order of the directories is relevant.

=load-path= is documented in the [[http://www.gnu.org/software/emacs/manual/html_node/emacs/Lisp-Libraries.html][Emacs Online Manual]], in chapter *Libraries of Lisp Code for Emacs*. Useful tips are also on [[http://www.emacswiki.org/emacs/LoadPath][EmacsWiki]].

#+BEGIN_SRC emacs-lisp
(let ((default-directory "~/.emacs.d/elisp/"))
  (unless (file-exists-p default-directory)
    (make-directory default-directory))
  (add-to-list 'load-path default-directory))
#+END_SRC

Here we create the directory =~/.emacs.d/elisp= if it does not exist, add it to the =load-path=. Doing that any =.el= or =.elc= files in this directory can be required from *emacs*.

** Package Archives

#+BEGIN_SRC emacs-lisp
(setq package-archives nil)
#+END_SRC

Remove the default GNU package archive since I use =quelpa= to install packages from source.

** Quelpa

#+BEGIN_QUOTE
Build and install your Emacs Lisp packages on-the-fly directly from source
#+END_QUOTE

All the packaging solutions that existed annoyed me so I wrote my own and called it =quelpa=.

Given a recipe in [[https://github.com/milkypostman/melpa#recipe-format][melpa's format]], it gets the package source code, builds an elpa compatible package and installs that. Packages can be managed in the usual way with =list-packages=.

Github: https://github.com/quelpa/quelpa

#+BEGIN_SRC emacs-lisp
(if (require 'quelpa nil t)
    (quelpa '(quelpa :repo "quelpa/quelpa" :fetcher github) :upgrade t)
  (with-temp-buffer
    (url-insert-file-contents "https://raw.github.com/quelpa/quelpa/master/bootstrap.el")
    (eval-buffer)))
#+END_SRC

Bootstrapping =quelpa= here. The =quelpa= command is used throughout this config to install all the packages. The only other package-archive I tolerate is the one from org-mode :)

** Key Bindings

#+BEGIN_SRC emacs-lisp
(defvar my-keys-minor-mode-map (make-keymap) "my-keys-minor-mode keymap.")
#+END_SRC

This is a custom keymap. It is used for a [[my-keys-minor-mode][minor mode that is activated at the end]]. This is the only way I know of to protect special combos (like =C-<return>=) from being overridden by other modes.

#+BEGIN_SRC emacs-lisp
(quelpa '(key-chord :fetcher wiki))
(key-chord-mode 1)
(setq key-chord-two-keys-delay 0.03)
#+END_SRC

#+BEGIN_QUOTE
Key-chord lets you bind commands to combination of key-strokes. Here a "key chord" means two keys pressed simultaneously, or a single key quickly pressed twice.
#+END_QUOTE

The source code can be found on [[http://www.emacswiki.org/emacs/key-chord.el][EmacsWiki]].

We need to turn the mode on here so that we can map keys further below. We lower the delay so that chords are not triggered too easily.

#+NAME: gen-keys
#+BEGIN_SRC emacs-lisp :var keys=keys :results output :tangle no :exports none :colnames nil
(mapcar (lambda (l)
          (let* ((key (car l))
                 (def (if (string-match "^[[:alnum:]]\\{2\\}$" (format "%s" key))
                          (format "key-chord-define-global \"%s\"" key)
                        (format "global-set-key (kbd \"%s\")" key)))
                 (command (car (last l))))
                 (princ (format "(%s %s)\n" def command))))
          keys)
#+END_SRC

#+BEGIN_SRC emacs-lisp :noweb yes :results silent
<<gen-keys()>>
#+END_SRC

The code for the keys is generated from data in an Org table named =keys= using a bit of Elisp code =gen-keys= and is spit out inside a code block via [[http://orgmode.org/manual/noweb.html][Noweb syntax]]. The same data is also used in the [[Keyboard%20shortcuts][Keyboard shortcuts]] section to generate the documentation. I'd like to be able to have only one place to change key information and have it updated wherever necessary.

#+BEGIN_SRC emacs-lisp
(define-key key-translation-map (kbd "C-t") (kbd "C-p"))
(define-key my-keys-minor-mode-map (kbd "<C-return>") 'helm-mini)
#+END_SRC

=C-t= is translated to =C-p= (move up), this helps me with navigating using the [[http://en.wikipedia.org/wiki/Dvorak_Simplified_Keyboard][Dvorak keyboard layout]].
=my-keys-minor-mode-map= is used to set =C-return= in this case in a way so that other minor modes cannot override it.

**** Key definition table                                          :noexport:
#+TBLNAME: keys
| Combo             | Category  | Desciption                                                | Command                                                     |
|-------------------+-----------+-----------------------------------------------------------+-------------------------------------------------------------|
| C-h x             | General   | Kill emacs (including the daemon if it is running)        | (lambda () (interactive) (shell-command "pkill emacs"))     |
| C-S-l             | General   | List available packages                                   | 'package-list-packages                                      |
| C-c n             | General   | Show file name + path, save to clipboard                  | 'my-show-file-name                                          |
| C-x a s           | General   | Toggle auto saving of buffers                             | 'auto-save-buffers-enhanced-toggle-activity                 |
| C-c d             | General   | Change dictionary                                         | 'ispell-change-dictionary                                   |
| C-c C-f           | General   | Toggle flyspell mode (spellchecking)                      | 'flyspell-mode                                              |
| C-h C-h           | General   | Helm M-x (execute command)                                | 'helm-M-x                                                   |
| C-h h             | General   | Helm navigate project files                               | 'helm-projectile                                            |
| <C-S-iso-lefttab> | General   | Helm for files                                            | 'helm-for-files                                             |
| C-h ,             | General   | Helm: find commands, functions, variables and faces       | 'helm-apropos                                               |
| C-h .             | General   | Helm: Emacs info manual                                   | 'helm-info-emacs                                            |
| C-h 4             | General   | Helm: Elisp info manual                                   | 'helm-info-elisp                                            |
| C-h 3             | General   | Helm: Locate an Elisp library                             | 'helm-locate-library                                        |
| C-h C-p           | General   | Open file                                                 | 'find-file                                                  |
| cg                | General   | Customize group                                           | 'customize-group                                            |
| C-c m             | Interface | Toggle the menu bar                                       | 'menu-bar-mode                                              |
| <C-mouse-5>       | Interface | Decrease the font size                                    | 'text-scale-decrease                                        |
| <C-mouse-4>       | Interface | Increase the font size                                    | 'text-scale-increase                                        |
| lu                | Interface | Show/hide the line numbers                                | 'linum-mode                                                 |
| C-x C-u           | Internet  | Prompt for URL and insert contents at point               | 'my-url-insert-file-contents                                |
| C-c C-w           | Internet  | Browse URL under cursor                                   | 'browse-url-at-point                                        |
| C-z               | Editing   | Undo - but do not trigger redo                            | 'undo-only                                                  |
| <M-f10>           | Editing   | Move line or region up                                    | 'move-text-up                                               |
| <M-f9>            | Editing   | Move line or region down                                  | 'move-text-down                                             |
| C-S-c C-S-c       | Editing   | Edit region with multiple cursors                         | 'mc/edit-lines                                              |
| C-<               | Editing   | Multiple cursors up                                       | 'mc/mark-previous-like-this                                 |
| C->               | Editing   | Multiple cursors down                                     | 'mc/mark-next-like-this                                     |
| C-*               | Editing   | Mark all like "this" with multiple cursors                | 'mc/mark-all-like-this                                      |
| vr                | Editing   | Visual regexp/replace                                     | 'vr/replace                                                 |
| i9                | Editing   | Toggle electric indent mode                               | 'electric-indent-mode                                       |
| ac                | Editing   | Align nearby elements                                     | 'align-current                                              |
| C-8               | Editing   | Select symbol under cursor, repeat to expand              | 'er/expand-region                                           |
| M-8               | Editing   | Contract the current selection                            | 'er/contract-region                                         |
| M-W               | Editing   | Delete region (but don't put it into kill ring)           | 'delete-region                                              |
| fc                | Editing   | Toggle flycheck mode                                      | 'flycheck-mode                                              |
| C-c q             | Editing   | Toggle word wrap                                          | 'auto-fill-mode                                             |
| C-c w             | Editing   | Cleanup whitespaces                                       | 'whitespace-cleanup                                         |
| C-h C-v           | Editing   | Toggle visual line mode                                   | 'visual-line-mode                                           |
| C-h TAB           | Editing   | Indent the whole buffer                                   | 'my-indent-whole-buffer                                     |
| M-5               | Source    | Helm select etags                                         | 'helm-etags-select                                          |
| M-6               | Source    | Find tag in a new window                                  | 'find-tag-other-window                                      |
| C-h C-0           | Source    | Edebug defun at point                                     | 'edebug-defun                                               |
| C-h C-b           | Source    | Evaluate the current buffer                               | 'eval-buffer                                                |
| C-h C-e           | Source    | Toggle debug on error                                     | 'toggle-debug-on-error                                      |
| C-h C-d           | Directory | Open dired in current file location                       | 'dired-jump                                                 |
| sb                | Directory | Open the speedbar                                         | 'speedbar                                                   |
| C-c T             | Directory | Open terminal in current directory                        | (lambda () (interactive) (my-open-terminal nil))            |
| C-c t             | Directory | Open terminal in current project root                     | (lambda () (interactive) (my-open-terminal t))              |
| C-h C-/           | Directory | Use fasd to navigate to a file or directory               | 'fasd-find-file                                             |
| C-h C-s           | Buffers   | Save the current buffer                                   | 'save-buffer                                                |
| C-c r             | Buffers   | Revert a buffer to the saved state                        | 'revert-buffer                                              |
| C-x C-b           | Buffers   | use ido to switch buffers                                 | 'ido-switch-buffer                                          |
| <f6>              | Buffers   | Kill current buffer                                       | (lambda () (interactive) (kill-buffer (buffer-name)))       |
| <f8>              | Buffers   | Switch to "other" buffer                                  | (lambda () (interactive) (switch-to-buffer nil))            |
| ht                | Buffers   | Switch to "other" buffer                                  | (lambda () (interactive) (switch-to-buffer nil))            |
| fv                | Buffers   | Kill current buffer                                       | (lambda () (interactive) (kill-buffer (buffer-name)))       |
| sv                | Buffers   | Save the current buffer                                   | 'save-buffer                                                |
| sc                | Buffers   | Switch to scratch buffer                                  | (lambda () (interactive)(switch-to-buffer "*scratch*"))     |
| <f9>              | Buffers   | Split window and show/hide last buffer                    | 'my-split-window                                            |
| C-h C-SPC         | History   | Helm show the kill ring                                   | 'helm-show-kill-ring                                        |
| C-h SPC           | History   | Helm show all mark rings                                  | 'helm-all-mark-rings                                        |
| C-3               | History   | Go backward in movement history                           | 'back-button-local-backward                                 |
| C-4               | History   | Go forward in movement history                            | 'back-button-local-forward                                  |
| M-2               | Occur     | Show all symbols like the one cursor is located at        | 'highlight-symbol-occur                                     |
| M-3               | Occur     | Previous symbol like the one the cursor is on             | (lambda () (interactive) (highlight-symbol-jump -1))        |
| M-4               | Occur     | Next symbol like the one the cursor is on                 | (lambda () (interactive) (highlight-symbol-jump 1))         |
| M-9               | Occur     | Helm search for occurences in open buffers                | 'helm-occur                                                 |
| 34                | Occur     | Helm imenu                                                | 'helm-imenu                                                 |
| M-i               | Occur     | Helm swoop                                                | 'helm-swoop                                                 |
| M-I               | Occur     | Helm swoop back to last point                             | 'helm-swoop-back-to-last-point                              |
| ok                | Occur     | Projectile multiple occur                                 | 'projectile-multi-occur                                     |
| C-0               | Windows   | Select previous window                                    | (lambda () (interactive) (select-window (previous-window))) |
| C-9               | Windows   | Select next window                                        | (lambda () (interactive) (select-window (next-window)))     |
| <f2>              | Windows   | Split window vertically                                   | 'split-window-vertically                                    |
| <f3>              | Windows   | Split window horizontally                                 | 'split-window-horizontally                                  |
| <f4>              | Windows   | Delete current window (not the buffer)                    | 'delete-window                                              |
| <f5>              | Windows   | Only keep the current window and delete all others        | 'delete-other-windows                                       |
| <f7>              | Windows   | Toggle arrangement of two windows horizontally/vertically | 'my-toggle-window-split                                     |
| <M-up>            | Windows   | Move the current buffer window up                         | 'buf-move-up                                                |
| <M-down>          | Windows   | Move the current buffer window down                       | 'buf-move-down                                              |
| <M-left>          | Windows   | Move the current buffer window left                       | 'buf-move-left                                              |
| <M-right>         | Windows   | Move the current buffer window right                      | 'buf-move-right                                             |
| C-h C-8           | Windows   | Enable/disable dedicated minor-mode for current window    | 'dedicated-mode                                             |
| vg                | Find/Grep | VC git grep                                               | 'vc-git-grep                                                |
| C-h C-f           | Find/Grep | Grep find                                                 | 'grep-find                                                  |
| C-S-h C-S-f       | Find/Grep | Find files in dired                                       | 'find-grep-dired                                            |
| C-h C-o           | Find/Grep | list matching regexp                                      | 'occur                                                      |
| C-h C-g           | Find/Grep | Use the ag cli tool to grep project                       | 'ag-project                                                 |
| C-h C-l           | Find/Grep | Helm locate                                               | 'helm-locate                                                |
| C-h C-z           | Find/Grep | Projectile find file                                      | 'projectile-find-file                                       |
| C-h g             | Find/Grep | Projectile grep                                           | 'projectile-grep                                            |
| C-h z             | Find/Grep | Projectile ack                                            | 'projectile-ack                                             |
| C-c g             | VCS       | Magit status - manual: http://magit.github.io/magit/      | 'magit-status                                               |
| C-c l             | VCS       | Magit log                                                 | 'magit-log                                                  |
| bm                | VCS       | Magit blame mode                                          | 'magit-blame-mode                                           |
| C-c s             | Open      | Open emacs shell                                          | 'shell                                                      |
| C-h r             | Open      | Open/hide dedicated term                                  | 'multi-term-dedicated-toggle                                |
| C-h C-c           | Open      | Next multi-term buffer                                    | 'multi-term-next                                            |
| C-h C-r           | Open      | Previous multi-term buffer                                | 'multi-term-prev                                            |
| C-h n             | Open      | New multi-term buffer                                     | 'multi-term                                                 |
| C-c c             | Open      | Open deft (quick notes tool)                              | 'deft                                                       |
| nm                | Open      | Open mu4e                                                 | 'mu4e                                                       |
| C-c e             | Open      | Open/connect with  ERC                                    | 'my-erc-connect                                             |
| C-h C-m           | Open      | Popup discover-my-major window                            | 'discover-my-major                                          |
| C-h C-<return>    | Open      | Emacs Web Wowser (internal Webbrowser)                    | 'eww                                                        |
| C-h M-RET         | Open      | Emacs Web Wowser do what I mean                           | 'my-eww-browse-dwim                                         |
| C-h C--           | Open      | Helm: Google                                              | 'helm-google                                                |
| C-h C-4           | Open      | Google translate                                          | 'google-translate-query-translate                           |
| C-h C-3           | Open      | Open Howdoi with query                                    | 'howdoi-query                                               |
| C-\"              | Open      | Open new terminal with shell-switcher                     | 'shell-switcher-new-shell                                   |
| C-h o             | Org       | Helm: Org info manual                                     | 'helm-info-org                                              |
| C-h C-n           | Org       | Open Org mode agenda                                      | (lambda () (interactive) (org-agenda nil "n"))              |
| C-h t             | Org       | Cpture simple task (todo)                                 | (lambda () (interactive) (org-capture nil "s"))             |
| C-h T             | Org       | Capture selection (todo)                                  | 'org-capture                                                |
| C-c i             | Org       | Start the clock on the current item                       | 'org-clock-in                                               |
| C-c o             | Org       | Stop the clock on the current item                        | 'org-clock-out                                              |
| C-S-g             | Org       | Goto the current org clock                                | 'org-clock-goto                                             |
| C-c C-9           | Org       | Insert a new subheading and demote it                     | 'org-insert-subheading                                      |
| C-c C-0           | Org       | Insert a new TODO subheading                              | 'org-insert-todo-subheading                                 |
| C-h C-.           | Org       | Open/switch to home.org                                   | (lambda () (interactive) (find-file "~/org/home.org"))      |
| C-h C-u           | Org       | Open/switch to work.org                                   | (lambda () (interactive) (find-file "~/org/work.org"))      |
| C-h C-w           | Org       | Cut the current subtree into the clipboard                | 'org-cut-subtree                                            |
| C-c v             | PHP       | var dump die template                                     | 'var_dump-die                                               |
| C-c V             | PHP       | var dump template                                         | 'var_dump                                                   |

** Settings

*** User Settings

#+BEGIN_SRC emacs-lisp
(when (file-readable-p "~/.user.el") (load "~/.user.el"))
#+END_SRC

Loads user settings if the file is available. I put all my personal modifications or sensitive information into this file.

*** Encoding

#+BEGIN_SRC emacs-lisp
(set-terminal-coding-system 'utf-8)
(set-keyboard-coding-system 'utf-8)
(set-language-environment "UTF-8")
(prefer-coding-system 'utf-8)
#+END_SRC

Kind of a sweeping blow to make sure UTF-8 is used everywhere.

*** General Settings

#+BEGIN_SRC emacs-lisp
(setq
 inhibit-startup-message t
 backup-directory-alist `((".*" . ,temporary-file-directory)) ;don't clutter my fs and put backups into tmp
 auto-save-file-name-transforms `((".*" ,temporary-file-directory t))
 column-number-mode t             ;show the column number
 default-major-mode 'text-mode    ;use text mode per default
 mouse-yank-at-point t     ;middle click with the mouse yanks at point
 history-length 250        ;default is 30
 locale-coding-system 'utf-8          ;utf-8 is default
 tab-always-indent 'complete          ;try to complete before identing
 confirm-nonexistent-file-or-buffer nil ;don't ask to create a buffer
 vc-follow-symlinks t                   ;follow symlinks automatically
 recentf-max-saved-items 5000           ;same up to 5000 recent files
 eval-expression-print-length nil       ;do not truncate printed expressions
 eval-expression-print-level nil        ;print nested expressions
 send-mail-function 'sendmail-send-it
 kill-ring-max 5000                     ;truncate kill ring after 5000 entries
 mark-ring-max 5000                     ;truncate mark ring after 5000 entries
 mouse-autoselect-window -.1            ;window focus follows the mouse pointer
 mouse-wheel-scroll-amount '(1 ((shift) . 5) ((control))) ;make mouse scrolling smooth
 indicate-buffer-boundaries 'left             ;fringe markers
 split-height-threshold 110                   ;more readily split horziontally
 enable-recursive-minibuffers t
 custom-unlispify-menu-entries nil      ;M-x customize should not cripple menu entries
 custom-unlispify-tag-names nil         ;M-x customize should not cripple tags
 show-paren-delay 0
 )

(put 'narrow-to-region 'disabled nil)   ;narrow to region should be enabled by default
#+END_SRC

This is kind of random stuff. I would like to organize this better but I didn't have a good idea for that yet.

*** Default Settings

#+BEGIN_SRC emacs-lisp
(setq-default
 tab-width 4
 indent-tabs-mode nil                   ;use spaces instead of tabs
 c-basic-offset 4                       ;"tab" with in c-related modes
 c-hungry-delete-key t                  ;delete more than one space
 )
#+END_SRC

Some variables like =tab-width= cannot be set globally:

#+BEGIN_QUOTE
tab-width is a variable defined in `C source code'.
...
Automatically becomes buffer-local when set.
#+END_QUOTE

Whenever they are set the value becomes buffer-local. To be able to set such a variable globally we have to use =setq-default= which modifies the default value of the variable.

*** Global Modes

#+BEGIN_SRC emacs-lisp
(global-auto-revert-mode 1)  ;auto revert buffers when changed on disk
(show-paren-mode t)          ;visualize()
(iswitchb-mode t)            ;use advanced tab switching
(blink-cursor-mode -1)       ;no cursor blinking
(tool-bar-mode -1)           ;disable the awful toolbar
(menu-bar-mode -1)           ;no menu, you can toggle it with C-c m
(scroll-bar-mode -1)         ;disable the sroll bar
#+END_SRC

These are built-in global modes/settings. Not sure where to put them so they ended up here...

*** Prompt Behavior

#+BEGIN_SRC emacs-lisp
(defalias 'yes-or-no-p 'y-or-n-p)

(setq kill-buffer-query-functions
  (remq 'process-kill-buffer-query-function
         kill-buffer-query-functions))
#+END_SRC

All "yes" or "no" questions are aliased to "y" or "n". We don't really want to type a full word to answer a question from Emacs, yet Emacs imposes that silly behavior on us. No!

Also Emacs should be able to kill processes without asking which is achieved in the second expression. Got that snippet from: http://www.masteringemacs.org/articles/2010/11/14/disabling-prompts-emacs/

** Theme, Faces, Frame

#+BEGIN_SRC emacs-lisp
(load-theme 'wombat)
#+END_SRC

#+BEGIN_SRC emacs-lisp
(set-frame-font "Inconsolata 14" nil t)
#+END_SRC

#+BEGIN_SRC emacs-lisp
(defun my-after-make-frame (frame)
  (when (find-font (font-spec :name "Symbola") frame)
    (dolist (range '((#x2600 . #x26ff)
                     (#x1f300 . #x1f5ff)
                     (#x1f600 . #x1f640)
                     (#x1f680 . #x1f6ff)))
      (set-fontset-font "fontset-default" range "Symbola"))))
(add-to-list 'after-make-frame-functions 'my-after-make-frame)
#+END_SRC

This will set =Symbola= as fallback-font for Emojis when it is available for the created frame. On Debian the font can be installed like this:

#+BEGIN_SRC shell-script :tangle no
sudo aptitude install ttf-ancient-fonts
#+END_SRC

#+BEGIN_SRC emacs-lisp
(setq frame-title-format
      '((:eval (if (buffer-file-name)
                   (abbreviate-file-name (buffer-file-name))
                 "%b"))))
#+END_SRC

For the frame title either show a file or a buffer name (if the buffer isn't visiting a file).

** Custom Functions
*** my-url-insert-file-contents

#+BEGIN_SRC emacs-lisp
(defun my-url-insert-file-contents (url)
  "Prompt for URL and insert file contents at point."
  (interactive "sURL: ")
  (url-insert-file-contents url))
#+END_SRC

*** my-find-function-or-variable-at-point

#+BEGIN_SRC emacs-lisp
(defun my-find-function-or-variable-at-point ()
  "Find directly the function/variable at point in the other window."
  (interactive)
  (let ((var (variable-at-point))
        (func (function-called-at-point)))
    (cond
     ((not (eq var 0)) (find-variable-other-window var))
      (func (find-function-other-window func))
       (t (message "Neither function nor variable found!")))))
(define-key emacs-lisp-mode-map (kbd "M-.") 'my-find-function-or-variable-at-point)
(define-key lisp-interaction-mode-map (kbd "M-.") 'my-find-function-or-variable-at-point)
#+END_SRC

I don't care if is a function or a variable... just go there, Emacs!

*** show-file-name

#+BEGIN_SRC emacs-lisp
(defun my-show-file-name ()
  "Show the full path file name in the minibuffer."
  (interactive)
  (message (buffer-file-name))
  (kill-new (file-truename buffer-file-name)))
#+END_SRC

Display and copy the full path of the file associated with the current buffer to the kill ring.

*** my-isearch-goto-match-beginning

#+BEGIN_SRC emacs-lisp
(defun my-isearch-goto-match-beginning ()
  (when (and isearch-forward (not isearch-mode-end-hook-quit)) (goto-char isearch-other-end)))
(add-hook 'isearch-mode-end-hook 'my-isearch-goto-match-beginning)
#+END_SRC

Make =isearch-forward= put the cursor at the start of the search, not the end, so that isearch can be used for navigation. See also http://www.emacswiki.org/emacs/IsearchOtherEnd.

*** my-indent-whole-buffer

#+BEGIN_SRC emacs-lisp
(defun my-indent-whole-buffer ()
  (interactive)
  (indent-region (point-min) (point-max)))
#+END_SRC

Indent the whole buffer with one command. Bound to =C-h TAB=.

*** my-show-help

#+BEGIN_SRC emacs-lisp
(quelpa '(pos-tip
          :repo "syohex/pos-tip"
          :fetcher github
          :files ("pos-tip.el")))
(require 'pos-tip)
(defun my-show-help (doc-function)
  "Show docs for symbol at point or at beginning of list if not on a symbol.
Pass symbol-name to the function DOC-FUNCTION."
  (interactive)
  (let ((s (symbol-name
            (save-excursion
              (or (symbol-at-point)
                  (progn (backward-up-list)
                         (forward-char)
                         (symbol-at-point)))))))
    (let ((doc-string (funcall doc-function s)))
      (if doc-string
          (pos-tip-show doc-string 'popup-tip-face (point) nil -1 60)
        (message "No documentation for %s" s)))))
(define-key lisp-mode-shared-map (kbd "C-c C-d")
  (lambda ()
    (interactive)
    (my-show-help #'ac-symbol-documentation)))
#+END_SRC

I wanted to be able to get a documentation popup without having to trigger auto-complete. It's mostly stolen from [[http://jaderholm.com/][Scott Jaderholm]] (the code is on [[http://www.emacswiki.org/emacs/AutoComplete][Emacswiki]]), but has been made more general to also work with other completion functions.

*** my-split-window

#+BEGIN_SRC emacs-lisp
(defun my-split-window()
  "Split the window to see the most recent buffer in the other window.
Call a second time to restore the original window configuration."
  (interactive)
  (if (eq last-command 'my-split-window)
      (progn
        (jump-to-register :my-split-window)
        (setq this-command 'my-unsplit-window))
    (window-configuration-to-register :my-split-window)
    (switch-to-buffer-other-window nil)))
#+END_SRC

I often use this to get back to the buffer I was editing just before. It has some problems and...

**** TODO I should be improving my-split-window

*** my-tks

#+BEGIN_SRC emacs-lisp
(defun my-tks (ipos tables params)
  "Formatting function for org `clocktable' that generates TKS compatible output.
Usage example:
,#+BEGIN: clocktable :scope agenda :block today :formatter my-tks :properties (\"project\")
,#+END: clocktable
"
  (insert-before-markers (format-time-string "%d/%m/%Y\n\n"))
  (let (tbl entry entries time)
    (while (setq tbl (pop tables))
      (setq entries (nth 2 tbl))
      (while (setq entry (pop entries))
        (when (string-match org-todo-regexp (nth 1 entry))
          (let* ((level (car entry))
                 (headline (replace-regexp-in-string (concat org-todo-regexp "\\( +\\|[ \t]*$\\)") "" (nth 1 entry)))
                 (rest (mod (nth 3 entry) 60))
                 (hours (/ (nth 3 entry) 60))
                 (mins (cond
                        ((<= rest 15) 0.25)
                        ((<= rest 30) 0.5)
                        ((<= rest 45) 0.75)
                        (t 1)))
                 (project (cdr (assoc "project" (nth 4 entry))))
                 )
            (insert-before-markers
             (format "%s %s %s\n" (if project project "?") (+ hours mins) headline ))
            ))))))
#+END_SRC

*** my-toggle-window-split

#+BEGIN_SRC emacs-lisp
(defun my-toggle-window-split ()
  (interactive)
  (if (= (count-windows) 2)
      (let* ((this-win-buffer (window-buffer))
             (next-win-buffer (window-buffer (next-window)))
             (this-win-edges (window-edges (selected-window)))
             (next-win-edges (window-edges (next-window)))
             (this-win-2nd (not (and (<= (car this-win-edges)
                                         (car next-win-edges))
                                     (<= (cadr this-win-edges)
                                         (cadr next-win-edges)))))
             (splitter
              (if (= (car this-win-edges)
                     (car (window-edges (next-window))))
                  'split-window-horizontally
                'split-window-vertically)))
        (delete-other-windows)
        (let ((first-win (selected-window)))
          (funcall splitter)
          (if this-win-2nd (other-window 1))
          (set-window-buffer (selected-window) this-win-buffer)
          (set-window-buffer (next-window) next-win-buffer)
          (select-window first-win)
          (if this-win-2nd (other-window 1))))))
#+END_SRC

This function allows to get two vertically splitted windows into a horizontal split and back.

** Advices

#+BEGIN_SRC emacs-lisp
(defadvice kill-ring-save (before slick-copy activate compile)
  "When called interactively with no active region, copy a single
line instead."
  (interactive
    (if mark-active (list (region-beginning) (region-end))
      (message "Copied line")
      (list (line-beginning-position)
               (line-beginning-position 2)))))

(defadvice kill-region (before slick-cut activate compile)
  "When called interactively with no active region, kill a single
line instead."
  (interactive
    (if mark-active (list (region-beginning) (region-end))
      (list (line-beginning-position)
        (line-beginning-position 2)))))
#+END_SRC

Make killing a bit more intelligent, so that when having no region the current line in operated on. See http://www.emacswiki.org/emacs/SlickCopy where this is copied from...

#+BEGIN_SRC emacs-lisp
(defadvice kill-buffer (around kill-buffer-around-advice activate)
  (let ((buffer-to-kill (ad-get-arg 0)))
    (if (equal buffer-to-kill "*scratch*")
        (bury-buffer)
      ad-do-it)))
#+END_SRC

Bury *scratch* buffer instead of killing it. I can't stand having to re-create *scratch*.

** Modes

Now get ready for setting up all the modes I use...

*** auctex-mode

#+BEGIN_QUOTE
AUCTEX is an extensible package for writing and formatting TEX files in GNU Emacs and XEmacs. It supports many different TEX macro packages, including AMS-TEX, LATEX, Texinfo, ConTEXt, and docTEX (dtx files).
#+END_QUOTE

https://www.gnu.org/software/auctex/img/preview-screenshot.png

Homepage: https://www.gnu.org/software/auctex/

#+BEGIN_SRC emacs-lisp
(setq TeX-PDF-mode t)
(setq TeX-parse-self t)
(setq TeX-auto-save t)
(setq TeX-save-query nil)
(add-hook 'doc-view-mode-hook 'auto-revert-mode)
(add-hook 'TeX-mode-hook
          '(lambda ()
             (define-key TeX-mode-map (kbd "<C-f8>")
               (lambda ()
                 (interactive)
                 (TeX-command-menu "LaTeX")))))
#+END_SRC

When I do LaTeX I want to have a sane config. I install =auctex= only when I really need it.

*** ag

#+BEGIN_SRC emacs-lisp
(quelpa '(ag :repo "Wilfred/ag.el" :fetcher github))
#+END_SRC

*** apache-mode

#+BEGIN_SRC emacs-lisp
(quelpa '(apache-mode :fetcher wiki))
#+END_SRC

*** back-button

#+BEGIN_QUOTE
Back-button provides an alternative method for navigation by analogy with the "back" button in a web browser.

Every Emacs command which pushes the mark leaves behind an invisible record of the location of the point at that moment. Back-button moves the point back and forth over all the positions where some command pushed the mark.
Visual navigation through mark rings in Emacs.
#+END_QUOTE

#+CAPTION: back-button
#+NAME: fig:bb
https://raw.github.com/rolandwalker/back-button/master/back_button_example.png

=back-button= is written by Roland Walker. For more information see the [[https://github.com/rolandwalker/back-button][Github page]].

#+BEGIN_SRC emacs-lisp
(quelpa '(back-button :repo "rolandwalker/back-button" :fetcher github))
(setq back-button-local-keystrokes nil) ;don't overwrite C-x SPC binding
(require 'back-button)
(back-button-mode 1)
#+END_SRC

*** buffer-move

#+BEGIN_SRC emacs-lisp
(quelpa '(buffer-move :fetcher wiki))
#+END_SRC

*** cider

#+BEGIN_QUOTE
CIDER is Clojure IDE and REPL for Emacs, built on top of nREPL, the Clojure networked REPL server. It's a great alternative to the now deprecated combination of SLIME + swank-clojure.
#+END_QUOTE

https://raw.github.com/clojure-emacs/cider/master/logo/cider-logo-w480.png

It was formerly called =nrepl.el= and is written by Bozhidar Batsov.

Github: https://github.com/clojure-emacs/cider

I wrote a company-backend for Cider which is living at https://github.com/clojure-emacs/company-cider.

#+BEGIN_SRC emacs-lisp
(quelpa '(cider :fetcher github :repo "clojure-emacs/cider" :old-names (nrepl)))
(setq cider-popup-stacktraces nil)
(setq cider-repl-popup-stacktraces nil)
(setq cider-repl-pop-to-buffer-on-connect t)
(setq cider-repl-use-clojure-font-lock t)
#+END_SRC

Don't popup nasty stacktraces all over the place, please.

*** company
#+BEGIN_QUOTE
Company stands for "complete anything". It uses pluggable back-ends and front-ends to retrieve and display completion candidates.

It comes with several back-ends such as Elisp, Clang, Semantic, Eclim, Ropemacs, Ispell, dabbrev, etags, gtags, files, keywords and a few others.
#+END_QUOTE

#+CAPTION: company
#+NAME: fig:co
http://company-mode.github.io/images/company-semantic.png

#+BEGIN_SRC emacs-lisp
(quelpa '(company :repo "company-mode/company-mode" :fetcher github))
(quelpa '(company-cider :fetcher github :repo "clojure-emacs/company-cider"))
(require 'company)
(setq company-idle-delay 0.3)
(setq company-tooltip-limit 20)
(setq company-minimum-prefix-length 2)
(setq company-echo-delay 0)
(setq company-auto-complete nil)
(global-company-mode 1)
(add-to-list 'company-backends 'company-dabbrev t)
(add-to-list 'company-backends 'company-ispell t)
(add-to-list 'company-backends 'company-files t)
(add-to-list 'company-backends 'company-cider)
#+END_SRC

I started using =company= because =auto-complete= seemed to be buggy and slow. Some of the company features are pretty cool, for example the ability to search within completions with =C-s= or to show the symbol definition with =C-w=. =<f1>= shows the full documentation of a symbol. I miss the popup from auto-complete a bit but I guess that's not so important in the end.

#+BEGIN_SRC emacs-lisp
(defun my-pcomplete-capf ()
  (add-hook 'completion-at-point-functions 'pcomplete-completions-at-point nil t))
(add-hook 'org-mode-hook #'my-pcomplete-capf)
#+END_SRC

This enables company completion for org-mode built-in commands and tags.

*** conf-mode

#+BEGIN_SRC emacs-lisp
(add-to-list 'auto-mode-alist '("\\.tks\\'" . org-mode))
#+END_SRC

*** dedicated

#+BEGIN_QUOTE
This minor mode allows you to toggle a window's "dedicated" flag. When a window is "dedicated", Emacs will not select files into that window. This can be quite handy since many commands will use another window to show results (e.g., compilation mode, starting info, etc.) A dedicated window won't be used for such a purpose.
#+END_QUOTE

Github: https://github.com/emacsmirror/dedicated

#+BEGIN_SRC emacs-lisp
(quelpa '(dedicated :fetcher github :repo "emacsmirror/dedicated"))
(require 'dedicated)
#+END_SRC

I'm quite fond of =dedicated=. Now when a buffer is supposed to be left alone, I can dedicate it!

*** deft

#+BEGIN_QUOTE
Deft is an Emacs mode for quickly browsing, filtering, and editing directories of plain text notes.
#+END_QUOTE

Homepage: http://jblevins.org/projects/deft/

#+CAPTION: deft
#+NAME: fig:deft
http://jblevins.org/projects/deft/browser.png

#+BEGIN_SRC emacs-lisp
(quelpa '(deft :url "git://jblevins.org/git/deft.git" :fetcher git))
(setq
 deft-extension "org"
 deft-directory "~/deft"
 deft-text-mode 'org-mode
 deft-use-filename-as-title t
 deft-auto-save-interval 20
 )
#+END_SRC

I'm using org-mode as the default format for deft. I mostly use deft to record some random notes and later archive them using the command provided by deft.

*** diff-hl

#+BEGIN_QUOTE
diff-hl-mode highlights uncommitted changes on the left side of the window, allows you to jump between and revert them selectively.
#+END_QUOTE

Github: https://github.com/dgutov/diff-hl

#+CAPTION: diff-hl
#+NAME: fig:diff-hl
https://raw.github.com/dgutov/diff-hl/master/screenshot.png

#+BEGIN_SRC emacs-lisp
(quelpa '(diff-hl :fetcher github :repo "dgutov/diff-hl"))
(global-diff-hl-mode)

(defadvice git-commit-commit (after git-commit-commit-after activate)
  (dolist (buffer (buffer-list))
    (with-current-buffer buffer
      (when diff-hl-mode
        (diff-hl-update)))))
#+END_SRC

Turn on the global mode and advice the commit-function so that after a commit the diff-hl-enabled buffers are updated.

*** dired and dired+

#+BEGIN_QUOTE
Dired makes an Emacs buffer containing a listing of a directory, and
optionally some of its subdirectories as well.  You can use the normal
Emacs commands to move around in this buffer, and special Dired commands
to operate on the listed files.
#+END_QUOTE

Dired is nice way to browse the directory tree. I have added =dired+= which

#+BEGIN_QUOTE
extends functionalities provided by standard GNU Emacs libraries dired.el, dired-aux.el, and dired-x.el. The standard functions are all available, plus many more.
#+END_QUOTE

http://www.emacswiki.org/pics/static/DrewsEmacsDiredLine.jpg

See the [[http://www.emacswiki.org/emacs/DiredPlus][EmacsWiki]] for detailed information on =dired+=.

Being in a dired buffer it is possible to make the buffer writable and thus rename files and permissions by editing the buffer. Use =C-x C-q= which runs the command =dired-toggle-read-only= to make that possible.

I often use =dired-jump= (mapped to =C-h C-d=) which jumps to Dired buffer corresponding to current buffer.

#+BEGIN_SRC emacs-lisp
(quelpa '(dired+ :fetcher wiki))
(setq dired-auto-revert-buffer t)
(setq wdired-allow-to-change-permissions t) ; allow changing of file permissions
(toggle-diredp-find-file-reuse-dir 1)
(setq diredp-hide-details-initially-flag nil)
(setq diredp-hide-details-propagate-flag nil)
#+END_SRC

It seems that both flags are necessary to make dired+ not hide the details. =toggle-diredp-find-file-reuse-dir= will make sure that there is only one buffer kept around for =dired=. Normally =dired= creates a buffer for every opened directory.

*** discover-my-major
#+BEGIN_QUOTE
Discover key bindings and their meaning for the current Emacs major mode.

The command is inspired by discover.el and also uses the makey library. I thought, "Hey! Why not parse the information about the major mode bindings somehow and display that like discover.el does..."
#+END_QUOTE

Github: https://github.com/steckerhalter/discover-my-major

#+BEGIN_SRC emacs-lisp
(quelpa '(discover-my-major :fetcher github :repo "steckerhalter/discover-my-major"))
#+END_SRC

*** elpy

Elpy makes setting up a great Python IDE a breeze. It's written by [[http://www.jorgenschaefer.de/][Jorgen Schäfer]] also known as =forcer=.

Github: https://github.com/jorgenschaefer/elpy

#+BEGIN_SRC emacs-lisp
(quelpa '(elpy
          :fetcher github
          :repo "jorgenschaefer/elpy"
          :branch "release"
          :files ("elpy.el" "elpy-refactor.el" "elpy-pkg.el.in" "snippets")))
(elpy-enable)
(delq 'flymake-mode elpy-default-minor-modes)
#+END_SRC

I'm using =flycheck= so please don't use =flymake= (which is old and bugly).

*** eval-sexp-fu

Flash some lights when evaluating expressions. See the EmacsWiki for some more info: http://www.emacswiki.org/emacs/EvalSexpFu

#+BEGIN_SRC emacs-lisp
(quelpa '(eval-sexp-fu :fetcher wiki :files ("eval-sexp-fu.el")))
(require 'eval-sexp-fu)
(setq eval-sexp-fu-flash-duration 0.4)
(turn-on-eval-sexp-fu-flash-mode)
(define-key lisp-interaction-mode-map (kbd "C-c C-c") 'eval-sexp-fu-eval-sexp-inner-list)
(define-key lisp-interaction-mode-map (kbd "C-c C-e") 'eval-sexp-fu-eval-sexp-inner-sexp)
(define-key emacs-lisp-mode-map (kbd "C-c C-c") 'eval-sexp-fu-eval-sexp-inner-list)
(define-key emacs-lisp-mode-map (kbd "C-c C-e") 'eval-sexp-fu-eval-sexp-inner-sexp)
#+END_SRC

*** erc mode

#+BEGIN_QUOTE
ERC is a powerful, modular, and extensible IRC client for Emacs.
#+END_QUOTE

I tried several IRC clients for Emacs but ERC is still my favorite.

EmacsWiki: http://www.emacswiki.org/emacs/ERC

#+BEGIN_SRC emacs-lisp
(quelpa '(erc-hl-nicks :fetcher github :repo "leathekd/erc-hl-nicks"))
(add-hook 'erc-mode-hook (lambda ()
                           (erc-truncate-mode t)
                           (erc-fill-disable)
                           (set (make-local-variable 'scroll-conservatively) 1000)
                           (visual-line-mode)))
(setq erc-timestamp-format "%H:%M "
      erc-fill-prefix "      "
      erc-insert-timestamp-function 'erc-insert-timestamp-left)
(setq erc-interpret-mirc-color t)
(setq erc-kill-buffer-on-part t)
(setq erc-kill-server-buffer-on-quit t)
(setq erc-kill-queries-on-quit t)
(setq erc-kill-server-buffer-on-quit t)
(setq erc-server-send-ping-interval 45)
(setq erc-server-send-ping-timeout 180)
(setq erc-server-reconnect-timeout 60)
(erc-track-mode t)
(setq erc-track-exclude-types '("JOIN" "NICK" "PART" "QUIT" "MODE"
                                "324" "329" "332" "333" "353" "477"))
(setq erc-hide-list '("JOIN" "PART" "QUIT" "NICK"))

;; ------ template for .user.el
;; (setq erc-prompt-for-nickserv-password nil)
;; (setq erc-server "hostname"
;;       erc-port 7000
;;       erc-nick "user"
;;       erc-user-full-name "user"
;;       erc-email-userid "user"
;;       erc-password "user:pw"
;;       )
#+END_SRC

#+BEGIN_SRC emacs-lisp
(defun my-erc-connect ()
  "Connect with ERC or open the last active buffer."
  (interactive)
  (if (erc-buffer-list)
      (erc-track-switch-buffer 1)
    (erc-tls :server erc-server :port erc-port :nick erc-nick :full-name erc-user-full-name :password erc-password)))
#+END_SRC

I use this function so that do not accidentally connect twice with ERC which happened quite often before.

*** eww
*Emacs Web Wowser* is the bult-in Emacs Webbrowser (Emacs 24.4 and later).

http://larsmagne23.files.wordpress.com/2013/06/eww.png

Rationale: http://lars.ingebrigtsen.no/2013/06/eww.html

#+BEGIN_SRC emacs-lisp
(setq eww-search-prefix "https://startpage.com/do/m/mobilesearch?query=")
#+END_SRC

Using [[https://startpage.com][startpage.com]] mobile view here as default search because the default duckduckgo is just too slow for my taste.

#+BEGIN_SRC emacs-lisp
(defun my-eww-browse-dwim ()
  "`eww' browse \"do what I mean\".
 Browse the url at point if there is one. Otherwise use the last
 kill-ring item and provide that to `eww'. If it is an url `eww'
 will browse it, if not `eww' will search for it using a search
 engine."
  (interactive)
  (let ((arg (or
              (url-get-url-at-point)
              (current-kill 0 t))))
    (eww arg)))
#+END_SRC

*** expand-region

#+BEGIN_SRC emacs-lisp
(quelpa '(expand-region :repo "magnars/expand-region.el" :fetcher github))
#+END_SRC

*** fasd

#+BEGIN_QUOTE
Fasd (pronounced similar to "fast") is a command-line productivity booster.
Fasd offers quick access to files and directories for POSIX shells. It is
inspired by tools like autojump
#+END_QUOTE

The command-line tool is available an Github: https://github.com/clvv/fasd

The =global-fasd-mode= was written by myself. It's purpose is to make the quick access DB from =fasd= available in Emacs and also to add visited files and directories from Emacs to the =fasd= DB.

Github: https://github.com/steckerhalter/emacs-fasd

#+BEGIN_SRC emacs-lisp
(quelpa '(fasd :repo "steckerhalter/emacs-fasd" :fetcher github))
(global-fasd-mode 1)
#+END_SRC

*** fixmee
#+BEGIN_QUOTE
Fixmee-mode tracks fixme notices in code comments, highlights them, ranks them by urgency, and lets you navigate to them quickly.

A distinguishing feature of this library is that it tracks the urgency of each notice, allowing the user to jump directly to the most important problems.
#+END_QUOTE

=fixmee= was written by Roland Walker and lives on Github: https://github.com/rolandwalker/fixmee

#+BEGIN_SRC emacs-lisp :tangle no
(quelpa '(fixmee :repo "rolandwalker/fixmee" :fetcher github))
(global-fixmee-mode 1)
#+END_SRC

I had tried similar modes like =fic-ext=mode= but fount them lacking a bit. Let's see how this one performs...

*** flycheck-mode

- Automatic on-the-fly syntax checking while editing
- Fully automatic selection of the best syntax checker

Supports many languages:  AsciiDoc, C/C++, CFEngine, Chef cookbooks, CoffeeScript, CSS, D, Elixir, Emacs Lisp, Erlang, Go, Haml, Handlebars, Haskell, HTML, Javascript, JSON, LESS, Lua, Perl, PHP, Puppet, Python, Ruby, Rust, RST (ReStructuredText), Sass, Scala, SCSS, Slim, Shell scripts (POSIX Shell, Bash and Zsh), TeX/LaTeX, XML, YAML

Flycheck is written by [[http://lunaryorn.com/][Sebastian Wiesner]] a.ka =lunaryorn=.

Github: https://github.com/flycheck/flycheck

https://raw.github.com/flycheck/flycheck/master/doc/images/screenshot.png

#+BEGIN_SRC emacs-lisp
(quelpa '(flycheck :repo "flycheck/flycheck" :fetcher github))
(add-hook 'php-mode-hook 'flycheck-mode)
(add-hook 'sh-mode-hook 'flycheck-mode)
(add-hook 'json-mode-hook 'flycheck-mode)
(add-hook 'nxml-mode-hook 'flycheck-mode)
(add-hook 'python-mode-hook 'flycheck-mode)
(add-hook 'emacs-lisp-mode-hook 'flycheck-mode)
(add-hook 'lisp-interaction-mode-hook 'flycheck-mode)
(setq-default flycheck-disabled-checkers '(emacs-lisp-checkdoc)) ;disable the annoying doc checker
(setq flycheck-indication-mode 'left-fringe)
#+END_SRC

The modes where flycheck should be enabled.

*** grizzl

#+BEGIN_QUOTE
Grizzl is a small utility library to be used in other Elisp code needing fuzzy search behaviour. It is optimized for large data sets, using a special type of lookup table and supporting incremental searches (searches where the result can be narrowed-down by only searching what is already matched).
#+END_QUOTE

The source code for Grizzl can be found on [[https://github.com/d11wtq/grizzl][Github]]. It is written by Chris Corbyn who also wrote the PHP REPL =Boris=.

http://i.imgur.com/n3EweV3.png

Currently it is used by [[https://github.com/bbatsov/projectile][Projectile]] in my config. I quite like Grizzl. It offers some benefits for when entries are longer. For most cases =IDO= is better suited though.

#+BEGIN_SRC emacs-lisp
(quelpa '(grizzl :repo "d11wtq/grizzl" :fetcher github))
(setq *grizzl-read-max-results* 30)
#+END_SRC

I would like to see more than just the default results of 10.

*** google-translate
#+BEGIN_SRC emacs-lisp
(quelpa '(google-translate :fetcher github :repo "atykhonov/google-translate"))
(setq google-translate-default-source-language "de")
(setq google-translate-default-target-language "en")
#+END_SRC
*** haskell-mode

Github: https://github.com/haskell/haskell-mode

#+BEGIN_SRC emacs-lisp
(quelpa '(haskell-mode :repo "haskell/haskell-mode" :fetcher github :files ("*.el" "haskell-mode.texi" "NEWS" "logo.svg")))
(require 'haskell-mode)
(setq haskell-indent-thenelse 3)
(add-hook 'haskell-mode-hook 'turn-on-haskell-doc-mode)
(add-hook 'haskell-mode-hook 'turn-on-haskell-indent)
#+END_SRC

I still have this lingering around here from way back then when I used the xmonad tiling window manager.

*** helm

#+BEGIN_QUOTE
Helm is incremental completion and selection narrowing framework for Emacs. It will help steer you in the right direction when you're looking for stuff in Emacs (like buffers, files, etc).

Helm is a fork of anything.el originaly written by Tamas Patrovic and can be considered to be its successor. Helm sets out to clean up the legacy code in anything.el and provide a cleaner, leaner and more modular tool, that's not tied in the trap of backward compatibility.
#+END_QUOTE

The Helm source code can be found [[https://github.com/emacs-helm/helm][at Github]].

You might want to checkout the [[https://github.com/emacs-helm/helm/wiki][Helm Wiki]] for detailed instructions on how Helm works.

#+BEGIN_SRC emacs-lisp
(quelpa '(helm :repo "emacs-helm/helm" :fetcher github :files ("*.el" "emacs-helm.sh")))
(quelpa '(helm-descbinds :repo "emacs-helm/helm-descbinds" :fetcher github))
(quelpa '(helm-gtags :repo "syohex/emacs-helm-gtags" :fetcher github :files ("helm-gtags.el")))
(quelpa '(helm-projectile :repo "bbatsov/projectile" :fetcher github :files ("helm-projectile.el")))
(require 'helm-config)
(setq helm-mode-handle-completion-in-region nil) ; don't use helm for `completion-at-point'
(helm-mode 1)
(helm-gtags-mode 1)
(helm-descbinds-mode)
(setq helm-idle-delay 0.1)
(setq helm-input-idle-delay 0.1)
(setq helm-buffer-max-length 50)
(setq helm-M-x-always-save-history t)
(setq helm-buffer-details-flag nil)
(add-to-list 'helm-completing-read-handlers-alist '(org-refile)) ; helm-mode does not do org-refile well
(add-to-list 'helm-completing-read-handlers-alist '(org-agenda-refile)) ; same goes for org-agenda-refile
#+END_SRC

I'm not using [[https://github.com/emacs-helm/helm/wiki#6-helm-find-files][Helm Find Files]] to browse files anymore. I tried using it but gave up after a while. I found it to be more cumbersome than [[*ido-mode][ido-mode]]. But in general I really like to have Helm around especially for buffer-switching. But it is also very useful to look up Elisp variable/function documentation and for finding stuff in the Info Manuals (e.g. =helm-info-elisp= or =helm-info-emacs=).

I use [[https://github.com/emacs-helm/helm/wiki#8-helm-m-x][Helm M-x]] and also the separate [[https://github.com/emacs-helm/helm-descbinds][Helm Descbinds]] (=C-h b=) to get a quick key bindings overview.

*** helm-google

#+BEGIN_SRC emacs-lisp
(quelpa '(helm-google :fetcher github :repo "steckerhalter/helm-google"))
#+END_SRC

*** helm-swoop

=helm-swoop= is a great Helm powered buffer search/occur interface:

#+CAPTION: helm-swoop
#+NAME: fig:swoop
https://raw.github.com/ShingoFukuyama/images/master/helm-multi-swoop.gif

Github: https://github.com/ShingoFukuyama/helm-swoop

#+BEGIN_SRC emacs-lisp
(quelpa '(helm-swoop :repo "ShingoFukuyama/helm-swoop" :fetcher github))
(define-key isearch-mode-map (kbd "M-i") 'helm-swoop-from-isearch)
#+END_SRC

*** highlight-symbol

#+BEGIN_QUOTE
Automatic and manual symbol highlighting for Emacs
#+END_QUOTE

Highlights the word/symbol at point and any other occurrences in view. Also allows to jump to the next or previous occurrence.

Homepage: http://nschum.de/src/emacs/highlight-symbol/
Github: https://github.com/nschum/highlight-symbol.el

http://nschum.de/src/emacs/highlight-symbol/highlight-symbol.png

#+BEGIN_SRC emacs-lisp
(quelpa '(highlight-symbol :fetcher github :repo "nschum/highlight-symbol.el"))
(setq highlight-symbol-on-navigation-p t)
(add-hook 'prog-mode-hook 'highlight-symbol-mode)
#+END_SRC

*** howdoi

#+BEGIN_QUOTE
Do you find yourself constantly Googling for how to do basic programing tasks? Suppose you want to know how to format a date in bash. Why open your browser and read through blogs when you can just M-x howdoi-query RET format date bash RET

Howdoi.el is a way to query Stack Overflow directly from the Emacs and get back the most upvoted answer to the first question that comes up for that query.
#+END_QUOTE

Github: https://github.com/atykhonov/emacs-howdoi

Very useful. Saves a lot of time by not having to go through that boring "emacs -> browser -> search engine -> stackoverflow -> emacs" loop...

#+BEGIN_SRC emacs-lisp
(quelpa '(howdoi :repo "atykhonov/emacs-howdoi" :fetcher github))
#+END_SRC

*** ido-mode

#+BEGIN_EXAMPLE
Interactively do things with buffers and files
#+END_EXAMPLE

Great mode to quickly select buffers/files etc. Is built into Emacs since v22.

Select the previous match with =C-r= and next match with =C-s=.
To open =dired= at the current location press =C-d=.
Make a directory with =M-m=.

Use =C-j= if you want to create a file with what you have entered (and not the match).

#+BEGIN_SRC emacs-lisp
(setq ido-enable-flex-matching t
      ido-auto-merge-work-directories-length -1
      ido-create-new-buffer 'always
      ido-everywhere t
      ido-default-buffer-method 'selected-window
      ido-max-prospects 32
      ido-use-filename-at-point 'guess
      )
(ido-mode 1)
(quelpa '(flx-ido :repo "lewang/flx" :fetcher github :files ("flx-ido.el")))
(flx-ido-mode 1)
(setq ido-use-faces nil)
#+END_SRC

I added flx-ido quite recently which does indeed improve the flex matching. A shout out to Le Wang who coded it.

Github: https://github.com/lewang/flx

*** iedit

#+BEGIN_QUOTE
Iedit allows you to edit one occurrence of some text in a buffer (possibly narrowed) or region, and simultaneously have other occurrences edited in the same way, with visual feedback as you type.
#+END_QUOTE

Github: https://github.com/victorhge/iedit

#+BEGIN_SRC emacs-lisp
(quelpa '(iedit :repo "victorhge/iedit" :fetcher github))
(require 'iedit)
(setq iedit-unmatched-lines-invisible-default t)
#+END_SRC

The option here makes only the lines with matches visible and hides the rest of the buffer.

*** ielm

IELM is short for Inferior Emacs Lisp Mode. It is a REPL for Emacs Lisp that is sometimes useful if you want to get immediate feedback and a prompt to work with. I tend to use the =*scratch*= buffer for explorations like that usually but would be probably better off to use IELM more often :)

#+BEGIN_SRC emacs-lisp
(eval-after-load 'ielm
  '(progn
     (add-hook 'inferior-emacs-lisp-mode-hook
               (lambda ()
                 (turn-on-eldoc-mode)))))
#+END_SRC

We need to tweak IELM a bit so we get completion and eldoc hints.

*** js2-mode

#+BEGIN_QUOTE
Improved JavaScript editing mode for GNU Emacs
#+END_QUOTE

Github: https://github.com/mooz/js2-mode

#+BEGIN_SRC emacs-lisp
(quelpa '(js2-mode :repo "mooz/js2-mode" :fetcher github))
(add-to-list 'auto-mode-alist '("\\.js$" . js2-mode))
(add-hook 'js2-mode-hook 'flycheck-mode)
#+END_SRC

*** json-mode

#+BEGIN_QUOTE
Major mode for editing JSON files.
Extends the builtin js-mode to add better syntax highlighting for JSON.
#+END_QUOTE

Github: https://github.com/joshwnj/json-mode

#+BEGIN_SRC emacs-lisp
(quelpa '(json-mode :fetcher github :repo "joshwnj/json-mode"))
(add-to-list 'auto-mode-alist '("\\.json\\'" . json-mode))
#+END_SRC

*** magit

Magit is the king of Git interaction for Emacs.

http://www.masteringemacs.org/wp-content/uploads/Screenshot-from-2013-12-06-142317.png

There's a short [[http://www.emacswiki.org/emacs/Magit#toc1][Crash Course on Emacswiki]]:

#+BEGIN_SRC org
- M-x magit-status to see git status, and in the status buffer:
- s to stage files
- c to commit (type in your commit message then C-c C-c to save the message and commit)
- b b to switch to a branch

Other handy keys:

- P P to do a git push
- F F to do a git pull

try to press TAB
#+END_SRC

I have bound =magit-status= to =C-c g= and =magit-log= to =C-c l=.

See the [[http://magit.github.io/magit/magit.html][Magit manual]] for more information.

#+BEGIN_SRC emacs-lisp
(quelpa '(magit :fetcher github
                :repo "magit/magit"
                :files ("magit.el" "magit-bisect.el" "magit-blame.el" "magit-key-mode.el" "magit-popup.el" "magit-wip.el" "magit.texi" "AUTHORS.md" "README.md")))
(quelpa '(helm-git :repo "maio/helm-git" :fetcher github)) ; helm-git needs magit
(require 'helm-git)
(when (fboundp 'file-notify-add-watch)
  (quelpa '(magit-filenotify :fetcher github :repo "magit/magit-filenotify"))
  (add-hook 'magit-status-mode-hook 'magit-filenotify-mode))
(setq magit-save-some-buffers nil) ;don't ask to save buffers
(setq magit-set-upstream-on-push t) ;ask to set upstream
(setq magit-diff-refine-hunk t) ;show word-based diff for current hunk
(setq magit-default-tracking-name-function 'magit-default-tracking-name-branch-only) ;don't track with origin-*
#+END_SRC

Committing should act like =git commit -a= by default.

When Emacs has been compiled with inotiy support...

#+BEGIN_SRC shell-script
./configure --with-file-notification=inotify
#+END_SRC

...the function =file-notify-add-watch= is bound and we add =magit-filenotify-mode= to the hook so that file updates get reflected automatically in magit status.

*** markdown-mode

#+BEGIN_SRC emacs-lisp
(quelpa '(markdown-mode :url "git://jblevins.org/git/markdown-mode.git" :fetcher git))
(add-to-list 'auto-mode-alist '("\\.markdown\\'" . gfm-mode))
(add-to-list 'auto-mode-alist '("\\.md\\'" . gfm-mode))
#+END_SRC

Enable markdown-mode when the file suffixes match.

*** move-text

Allows to move the current line or region up/down. The source code is on the Wiki: http://www.emacswiki.org/emacs/move-text.el

#+BEGIN_SRC emacs-lisp
(quelpa '(move-text :fetcher wiki))
(require 'move-text)
#+END_SRC

*** mu4e

Mail client for Emacs by Dirk-Jan Binnema a.k.a =djcb=

http://www.djcbsoftware.nl/code/mu/mu.jpg

Website: http://www.djcbsoftware.nl/code/mu/
Github: https://github.com/djcb/mu

http://www.djcbsoftware.nl/code/mu/mu4e-splitview.png

#+BEGIN_SRC emacs-lisp
(when (file-exists-p "/usr/local/share/emacs/site-lisp/mu4e")
  (add-to-list 'load-path "/usr/local/share/emacs/site-lisp/mu4e")
  (autoload 'mu4e "mu4e" "Mail client based on mu (maildir-utils)." t)
  (require 'org-mu4e)
  ;; enable inline images
  (setq mu4e-view-show-images t)
  ;; use imagemagick, if available
  (when (fboundp 'imagemagick-register-types)
    (imagemagick-register-types))
  (setq mu4e-html2text-command "html2text -utf8 -width 72")
  (setq mu4e-update-interval 60)
  (setq mu4e-auto-retrieve-keys t)
  (setq mu4e-headers-leave-behavior 'apply)
  (setq mu4e-headers-visible-lines 20)
  (setq mu4e-hide-index-messages t)

  (add-hook 'mu4e-headers-mode-hook (lambda () (local-set-key (kbd "X") (lambda () (interactive) (mu4e-mark-execute-all t)))))
  (add-hook 'mu4e-view-mode-hook (lambda () (local-set-key (kbd "X") (lambda () (interactive) (mu4e-mark-execute-all t)))))

  (defun mu4e-headers-mark-all-unread-read ()
    (interactive)
    (mu4e~headers-mark-for-each-if
     (cons 'read nil)
     (lambda (msg param)
       (memq 'unread (mu4e-msg-field msg :flags)))))

  (defun mu4e-flag-all-read ()
    (interactive)
    (mu4e-headers-mark-all-unread-read)
    (mu4e-mark-execute-all t))

  (setq message-kill-buffer-on-exit t))
#+END_SRC

*** multiple-cursors

#+BEGIN_SRC emacs-lisp
(quelpa '(multiple-cursors :fetcher github :repo "magnars/multiple-cursors.el"))
#+END_SRC

*** nrepl-eval-sexp-fu

Flashes the evaluated expression (visual feedback)

#+BEGIN_SRC emacs-lisp :tangle no
(quelpa '(nrepl-eval-sexp-fu :fetcher github :repo "samaaron/nrepl-eval-sexp-fu"))
(require 'nrepl-eval-sexp-fu)
(setq nrepl-eval-sexp-fu-flash-duration 0.4)
#+END_SRC

*** ob-php
#+BEGIN_SRC emacs-lisp
(quelpa '(ob-php :fetcher github :repo "steckerhalter/ob-php"))
(add-to-list 'org-babel-load-languages '(php . t))
(org-babel-do-load-languages 'org-babel-load-languages org-babel-load-languages)
#+END_SRC

*** org-mode

#+BEGIN_QUOTE
Org mode is for keeping notes, maintaining TODO lists, planning projects, and authoring documents with a fast and effective plain-text system.
#+END_QUOTE

Org mode is the most amazing tool for Emacs. Even this Emacs configuration is written and annotated with it.

Homepage: http://orgmode.org/

**** General settings

#+BEGIN_SRC emacs-lisp
;; we get `org' with contrib, so if the included `htmlize' is not available we need to force an upgrade
(let ((quelpa-upgrade-p (not (require 'htmlize nil t))))
  (quelpa '(org :url "git://orgmode.org/org-mode.git" :fetcher git
                :files ("lisp/*.el" "contrib/lisp/*.el" "doc/dir" "doc/*.texi"))))
(require 'org)
(require 'ox-org)
(require 'ox-md)
(add-to-list 'auto-mode-alist '("\\.org\\'" . org-mode))
(setq org-startup-folded t)
(setq org-startup-indented nil)
(setq org-startup-with-inline-images t)
(setq org-startup-truncated t)
(setq org-src-fontify-natively t)
(setq org-src-tab-acts-natively t)
(setq org-edit-src-content-indentation 0)
(setq org-confirm-babel-evaluate nil)
(setq org-use-speed-commands t)
(setq org-refile-targets '((org-agenda-files :maxlevel . 3)))
(setq org-refile-use-outline-path 'file)
(setq org-default-notes-file (concat org-directory "/notes.org"))
(add-to-list 'org-modules 'org-habit)
(setq org-habit-graph-column 60)

;; Don't use the same TODO state as the current heading for new heading
(defun my-org-insert-todo-heading () (interactive) (org-insert-todo-heading t))
(define-key org-mode-map (kbd "<M-S-return>") 'my-org-insert-todo-heading)
#+END_SRC

**** Agenda

#+BEGIN_SRC emacs-lisp
;; create the file for the agendas if it doesn't exist
(let ((agendas "~/.agenda_files"))
  (unless (file-readable-p agendas)
    (with-temp-file agendas nil))
  (setq org-agenda-files agendas))

;; display the agenda first
(setq org-agenda-custom-commands
      '(("n" "Agenda and all TODO's"
        ((alltodo "")
         (agenda "")))))

(defun my-initial-buffer-choice ()
  (org-agenda nil "n")
  (delete-other-windows)
  (current-buffer))
(setq initial-buffer-choice #'my-initial-buffer-choice)

(setq org-agenda-start-with-log-mode t)
(setq org-agenda-todo-ignore-scheduled 'future) ; don't show future scheduled
(setq org-agenda-todo-ignore-deadlines 'far)    ; show only near deadlines

(setq
 appt-message-warning-time 30
 appt-display-interval 15
 appt-display-mode-line t      ; show in the modeline
 appt-display-format 'window)
(appt-activate 1)              ; activate appt (appointment notification)

(org-agenda-to-appt)           ; add appointments on startup

;; add new appointments when saving the org buffer, use 'refresh argument to do it properly
(defun my-org-agenda-to-appt-refresh () (org-agenda-to-appt 'refresh))
(defun my-org-mode-hook ()
  (add-hook 'after-save-hook 'my-org-agenda-to-appt-refresh nil 'make-it-local))
(add-hook 'org-mode-hook 'my-org-mode-hook)

(require 'notifications)
(defun my-appt-disp-window-function (min-to-app new-time msg)
  (notifications-notify :title (format "Appointment in %s min" min-to-app) :body msg))
(setq appt-disp-window-function 'my-appt-disp-window-function)
(setq appt-delete-window-function (lambda (&rest args)))

;; add state to the sorting strategy of todo
(setcdr (assq 'todo org-agenda-sorting-strategy) '(todo-state-up priority-down category-keep))
#+END_SRC

**** Templates

#+BEGIN_SRC emacs-lisp
(setq org-capture-templates
      '(
        ("t" "Task" entry (file "") "* TODO %?\n %a")
        ("s" "Simple Task" entry (file "") "* TODO %?\n")
        ))

(add-to-list 'org-structure-template-alist '("E" "#+BEGIN_SRC emacs-lisp\n?\n#+END_SRC\n"))
(add-to-list 'org-structure-template-alist '("S" "#+BEGIN_SRC shell-script\n?\n#+END_SRC\n"))
#+END_SRC

**** Todo

#+BEGIN_SRC emacs-lisp
(setq org-todo-keywords
      '((sequence
         "TODO(t)"
         "WAITING(w)"
         "SCHEDULED(s)"
         "FUTURE(f)"
         "|"
         "DONE(d)"
         )))
(setq org-todo-keyword-faces
      '(
        ("SCHEDULED" . warning)
        ("WAITING" . font-lock-doc-face)
        ("FUTURE" . "white")
        ))
(setq org-log-into-drawer t) ; don't clutter files with state logs
#+END_SRC

**** Clocking

#+BEGIN_SRC emacs-lisp
(setq org-clock-idle-time 15)
(setq org-clock-in-resume t)
(setq org-clock-persist t)
(setq org-clock-persist-query-resume nil)
(when (executable-find "xprintidle")
  (setq org-x11idle-exists-p t)
  (setq org-clock-x11idle-program-name "xprintidle"))
(org-clock-persistence-insinuate)
(setq org-clock-frame-title-format (append '((t org-mode-line-string)) '(" ") frame-title-format))
(setq org-clock-clocked-in-display 'both)
#+END_SRC

**** org-mode-blog

Load the project template for my blog

#+BEGIN_SRC emacs-lisp
(let ((file (expand-file-name "elisp/org-mode-blog-setup.el" "~/org-mode-blog")))
  (when (file-exists-p file)
    (load file t t t)))
#+END_SRC

Don't forget to set =org-mode-blog-publishing-directory= to the desired export location in =~/.user.el=.

**** org-mobile-sync-mode

#+BEGIN_SRC emacs-lisp
(when (and (boundp 'org-mobile-directory) (version<= "24.3.50" emacs-version))
  (quelpa '(org-mobile-sync :repo "steckerhalter/org-mobile-sync" :fetcher github))
  (setq org-mobile-inbox-for-pull (concat org-directory "/notes.org"))
  (org-mobile-sync-mode 1))
#+END_SRC

Enable sync mode only if =org-mobile-directory= is set.

**** LaTeX

#+BEGIN_SRC emacs-lisp
(require 'ox-latex)
(add-to-list 'org-latex-packages-alist '("" "minted"))
(setq org-latex-listings 'minted)

(setq org-latex-pdf-process
      '("pdflatex -shell-escape -interaction nonstopmode -output-directory %o %f"
        "pdflatex -shell-escape -interaction nonstopmode -output-directory %o %f"
        "pdflatex -shell-escape -interaction nonstopmode -output-directory %o %f"))

#+END_SRC

*** php-mode

The well maintained version of PHP mode by Eric James Michael Ritz or =ejmr=

Github: https://github.com/ejmr/php-mode

#+BEGIN_SRC emacs-lisp
(quelpa '(geben :fetcher svn :url "http://geben-on-emacs.googlecode.com/svn/trunk/"))
(quelpa '(php-align :fetcher github :repo "tetsujin/emacs-php-align"))
(quelpa '(php-boris :repo "tomterl/php-boris" :fetcher github))
(quelpa '(php-boris-minor-mode :fetcher github :repo "steckerhalter/php-boris-minor-mode"))
(quelpa '(php-eldoc :repo "sabof/php-eldoc" :fetcher github :files ("*.el" "*.php")))
(quelpa '(php-mode :repo "ejmr/php-mode" :fetcher github))

(require 'php-mode)
(add-to-list 'auto-mode-alist '("\\.module\\'" . php-mode))
(setq php-mode-coding-style "Symfony2")
(setq php-template-compatibility nil)

(let ((manual "/usr/share/doc/php-doc/html/"))
  (when (file-readable-p manual)
    (setq php-manual-path manual)))

(defun my-php-completion-at-point ()
  "Provide php completions for completion-at-point.
Relies on functions of `php-mode'."
  (let ((pattern (php-get-pattern)))
    (when pattern
      (list (- (point) (length pattern)) (point) (php-completion-table) :exclusive 'no))))

(defun setup-php-mode ()
  (require 'php-align nil t)
  (add-hook 'completion-at-point-functions 'my-php-completion-at-point nil t)
  (php-align-setup)
  (set (make-local-variable 'electric-indent-mode) nil)
  (php-eldoc-enable))
(add-hook 'php-mode-hook 'setup-php-mode)
#+END_SRC

Adding some goodies like =php-documentor= to add docstrings and =php-align= to align on =\==.

#+BEGIN_SRC emacs-lisp
(defun var_dump-die ()
  (interactive)
  (let ((expression (if (region-active-p)
                        (buffer-substring (region-beginning) (region-end))
                      (sexp-at-point)))
        (line (thing-at-point 'line))
        (pre "die(var_dump(")
        (post "));"))
    (if expression
        (progn
          (beginning-of-line)
          (if (string-match "return" line)
              (progn
                (newline)
                (previous-line))
            (next-line)
            (newline)
            (previous-line))
          (insert pre)
          (insert (format "%s" expression))
          (insert post))
      ()
      (insert pre)
      (insert post)
      (backward-char (length post)))))

(defun var_dump ()
  (interactive)
  (if (region-active-p)
    (progn
      (goto-char (region-end))
      (insert ");")
      (goto-char (region-beginning))
      (insert "var_dump("))
    (insert "var_dump();")
    (backward-char 3)))
#+END_SRC

Two functions to insert =var_dump...= quickly.

*** prog-mode

#+BEGIN_SRC emacs-lisp
(add-hook 'prog-mode-hook (lambda () (interactive) (setq show-trailing-whitespace 1)))
#+END_SRC

Show whitespace errors in all programming modes by turning on =show-trailing-whitespace= in these modes.

*** projectile

#+BEGIN_QUOTE
Projectile is a project interaction library for Emacs. Its goal is to provide a nice set of features operating on a project level without introducing external dependencies(when feasible). For instance - finding project files has a portable implementation written in pure Emacs Lisp without the use of GNU find(but for performance sake an indexing mechanism backed by external commands exists as well).
#+END_QUOTE

Projectile is written by Bozhidar Batsov.

Github: https://github.com/bbatsov/projectile

https://raw.github.com/bbatsov/projectile/master/screenshots/projectile.png

#+BEGIN_SRC emacs-lisp
(quelpa '(projectile :repo "bbatsov/projectile" :fetcher github :files ("projectile.el")))
(require 'projectile nil t)
(setq projectile-completion-system 'grizzl)
#+END_SRC

*** rainbow-mode

#+BEGIN_QUOTE
rainbow-mode is a minor mode for Emacs which displays strings representing colors with the color they represent as background. It's disabled at the moment since it seems to be incompatible with the emacs version packaged in Debian.
#+END_QUOTE

http://julien.danjou.info/media/images/rainbow-mode/rainbow-mode.png

Homepage: http://julien.danjou.info/projects/emacs-packages#rainbow-mode

#+BEGIN_SRC emacs-lisp :tangle no
(unless (require 'rainbow-mode nil t)
  (with-temp-buffer
    (url-insert-file-contents
     "http://git.savannah.gnu.org/cgit/emacs/elpa.git/plain/packages/rainbow-mode/rainbow-mode.el")
    (package-install-from-buffer)))

(dolist (hook '(css-mode-hook
                html-mode-hook
                js-mode-hook
                emacs-lisp-mode-hook
                org-mode-hook
                text-mode-hook
                ))
  (add-hook hook 'rainbow-mode))
#+END_SRC

*** recentf

#+BEGIN_QUOTE
This package maintains a menu for visiting files that were operated on recently.  When enabled a new "Open Recent" sub menu is displayed in the "File" menu.  The recent files list is automatically saved across Emacs sessions.  You can customize the number of recent files displayed, the location of the menu and others options (see the source code for details).
#+END_QUOTE

#+BEGIN_SRC emacs-lisp
(setq recentf-save-file (expand-file-name "~/.recentf"))
(recentf-mode 1)
#+END_SRC

*** robe

#+BEGIN_QUOTE
Code navigation, documentation lookup and completion for Ruby
#+END_QUOTE

Github: https://github.com/dgutov/robe

#+BEGIN_SRC emacs-lisp
(quelpa '(robe :repo "dgutov/robe" :fetcher github :files ("robe*.el" "lib")))
(push 'company-robe company-backends)
(add-hook 'ruby-mode-hook 'robe-mode)
#+END_SRC

Enable =robe= for ruby buffers and since I'm using =company= I'm adding the backend here.

*** saveplace

#+BEGIN_QUOTE
Automatically save place in each file. This means when you visit a file, point goes to the last place
where it was when you previously visited the same file.
#+END_QUOTE

#+BEGIN_SRC emacs-lisp
(require 'saveplace)
(setq-default save-place t)
#+END_SRC

I find this quite practical...

*** savehist

#+BEGIN_QUOTE
Many editors (e.g. Vim) have the feature of saving minibuffer history to an external file after exit.  This package provides the same feature in Emacs. When set up, it saves recorded minibuffer histories to a file.
#+END_QUOTE

#+BEGIN_SRC emacs-lisp
(setq savehist-additional-variables '(kill-ring mark-ring global-mark-ring search-ring regexp-search-ring extended-command-history))
(savehist-mode 1)
#+END_SRC

I'm adding a few variables like the =extended-command-history= that I would like to persist too.

*** seqential-command

Do different things on repeated keypresses.

EmacsWiki: http://www.emacswiki.org/emacs/sequential-command.el

#+BEGIN_SRC emacs-lisp
(quelpa '(sequential-command :fetcher wiki :files ("sequential-command.el" "sequential-command-config.el")))
(require 'sequential-command)
(define-sequential-command my-beg back-to-indentation beginning-of-line)
(global-set-key "\C-a" 'my-beg)
#+END_SRC

Pressing =C-a= once goes back to the indentation, pressing it twice goes the beginning of the line.
Pressing =C-e= once goes back to the end of the line, pressing it twice advances to the next line's indentation.

*** shell-switcher
#+BEGIN_QUOTE
An emacs minor mode to easily switch between shell buffers (like with alt+tab)
#+END_QUOTE

Github: https://github.com/DamienCassou/shell-switcher

#+BEGIN_SRC emacs-lisp
(quelpa '(shell-switcher :fetcher github :repo "DamienCassou/shell-switcher" :files ("rswitcher.el" "shell-switcher.el")))
(setq shell-switcher-new-shell-function 'shell-switcher-make-ansi-term)
(setq shell-switcher-mode t)
(require 'shell-switcher)
#+END_SRC

*** skewer

#+BEGIN_QUOTE
Provides live interaction with JavaScript, CSS, and HTML in a web browser. Expressions are sent on-the-fly from an editing buffer to be evaluated in the browser, just like Emacs does with an inferior Lisp process in Lisp modes.
#+END_QUOTE

The following bookmarklet will load skewer on demand on any website:

#+BEGIN_SRC js
javascript:(function) {
    var d=document;
    var s=d.createElement('script');
    s.src='http://localhost:8080/skewer';
    d.body.appendChild(s);
})()
#+END_SRC

Instructions and the source code can be found [[https://github.com/skeeto/skewer-mode][on Github]].

#+BEGIN_SRC emacs-lisp
(quelpa '(skewer-mode :repo "skeeto/skewer-mode" :fetcher github :files ("*.html" "*.js" "*.el")))
(skewer-setup)
#+END_SRC

*** smart-mode-line

#+BEGIN_QUOTE
Smart Mode Line is a sexy mode-line for Emacs, that aims to be easy to read from small to large monitors by using a prefix feature and smart truncation.
#+END_QUOTE

https://raw.github.com/Bruce-Connor/smart-mode-line/master/screenshot-2013-11-11-dark.png

It is written by Artur Bruce-Connor. The default Emacs mode-line has some shortcomings and =sml= does a good job at improving it.

Github: https://github.com/Bruce-Connor/smart-mode-line

#+BEGIN_SRC emacs-lisp
(quelpa '(smart-mode-line :repo "Bruce-Connor/smart-mode-line" :fetcher github))
(setq sml/vc-mode-show-backend t)
(sml/setup)
(sml/apply-theme 'respectful)
#+END_SRC

Show the encoding and add VC information to the mode-line. Respect the theme-colors and customize some of the =sml= colors.

*** smartparens

#+BEGIN_QUOTE
Smartparens is minor mode for Emacs that deals with parens pairs and tries to be smart about it. It started as a unification effort to combine functionality of several existing packages in a single, compatible and extensible way to deal with parentheses, delimiters, tags and the like.
#+END_QUOTE

Github: https://github.com/Fuco1/smartparens

#+BEGIN_SRC emacs-lisp
(quelpa '(smartparens :fetcher github :repo "Fuco1/smartparens"))
(require 'smartparens-config)
(smartparens-global-mode t)
;; "fix"" highlight issue in scratch buffer
(custom-set-faces '(sp-pair-overlay-face ((t ()))))
(define-key sp-keymap (kbd "C--") 'sp-forward-sexp)
(define-key sp-keymap (kbd "C-=") 'sp-backward-sexp)
(define-key sp-keymap (kbd "C-.") 'sp-down-sexp)
(define-key sp-keymap (kbd "C-,") 'sp-backward-down-sexp)
(define-key sp-keymap (kbd "C-S-a") 'sp-beginning-of-sexp)
(define-key sp-keymap (kbd "C-S-e") 'sp-end-of-sexp)
(define-key sp-keymap (kbd "C-M-e") 'sp-up-sexp)
(define-key sp-keymap (kbd "C-M-u") 'sp-backward-up-sexp)
(define-key sp-keymap (kbd "C-M-n") 'sp-next-sexp)
(define-key sp-keymap (kbd "C-M-p") 'sp-previous-sexp)
(define-key sp-keymap (kbd "C-S-k") 'sp-kill-sexp)
(define-key sp-keymap (kbd "C-S-w") 'sp-copy-sexp)
(define-key sp-keymap (kbd "M-S-<backspace>") 'sp-unwrap-sexp)
(define-key sp-keymap (kbd "M-<backspace>") 'sp-backward-unwrap-sexp)
(define-key sp-keymap (kbd "C-)") 'sp-forward-slurp-sexp)
(define-key sp-keymap (kbd "C-}") 'sp-forward-barf-sexp)
(define-key sp-keymap (kbd "C-(") 'sp-backward-slurp-sexp)
(define-key sp-keymap (kbd "C-{") 'sp-backward-barf-sexp)
(define-key sp-keymap (kbd "M-D") 'sp-splice-sexp)
(define-key sp-keymap (kbd "C-S-<backspace>") 'sp-splice-sexp-killing-forward)
(define-key sp-keymap (kbd "C-M-<backspace>") 'sp-splice-sexp-killing-backward)
(define-key sp-keymap (kbd "C-S-f") 'sp-select-next-thing)
(define-key sp-keymap (kbd "C-S-b") 'sp-select-previous-thing)
(define-key sp-keymap (kbd "C-]") 'sp-select-next-thing-exchange)
(define-key sp-keymap (kbd "C-\\") 'sp-select-previous-thing-exchange)
(define-key sp-keymap (kbd "C-M-]") 'sp-select-next-thing)
(define-key sp-keymap (kbd "M-F") 'sp-forward-symbol)
(define-key sp-keymap (kbd "M-B") 'sp-backward-symbol)
(define-key sp-keymap (kbd "M-S") 'sp-split-sexp)
(define-key sp-keymap (kbd "M-r") 'sp-splice-sexp-killing-around)
(sp-with-modes sp--lisp-modes
  (sp-local-pair "(" nil :wrap "C-M-9"))
#+END_SRC

I have finally started learning the =smartparens-bindings= and already customized the =sp-smartparens-bindings= a bit.

*** sgml

#+BEGIN_SRC emacs-lisp
(setq sgml-basic-offset 4)
(add-hook 'sgml-mode-hook 'sgml-electric-tag-pair-mode)
#+END_SRC

Use 4 spaces for identation and enable =sgml-electric-tag-pair-mode= so that editing an opening markup tag automatically updates the closing tag.

*** slime

#+BEGIN_QUOTE
SLIME, the Superior Lisp Interaction Mode for Emacs, is an Emacs mode for developing Common Lisp applications.
#+END_QUOTE

http://common-lisp.net/project/slime/images/more-slime.png

Homepage: http://www.common-lisp.net/project/slime/
Github: https://github.com/slime/slime

#+BEGIN_SRC emacs-lisp
(when (file-exists-p "~/quicklisp/slime-helper.el") (load "~/quicklisp/slime-helper.el"))
#+END_SRC

*** term-mode

#+BEGIN_QUOTE
The =Emacs Terminal Emulator= uses Term mode, which has two input modes.  In line mode, Term basically acts like Shell mode.  In char mode, each character is sent directly to the subshell, except for the Term escape character, normally ‘C-c’.
#+END_QUOTE

#+BEGIN_SRC emacs-lisp
(defun my-term-toggle-char-line-mode ()
  "Toggle between `term-char-mode' and `term-line-mode'."
  (interactive)
  (when (equal major-mode 'term-mode)
    (if (term-in-line-mode)
        (term-char-mode)
      (term-line-mode))))

(defun my-term-setup ()
  (interactive)
  (define-key term-raw-map (kbd "C-y") 'term-send-raw)
  (define-key term-raw-map (kbd "C-p") 'term-send-raw)
  (define-key term-raw-map (kbd "C-n") 'term-send-raw)
  (define-key term-raw-map (kbd "C-s") 'term-send-raw)
  (define-key term-raw-map (kbd "C-r") 'term-send-raw)
  (define-key term-raw-map (kbd "M-d") (lambda () (interactive) (term-send-raw-string "\ed")))
  (define-key term-raw-map (kbd "<C-backspace>") (lambda () (interactive) (term-send-raw-string "\e\C-?")))
  (define-key term-raw-map (kbd "M-p") (lambda () (interactive) (term-send-raw-string "\ep")))
  (define-key term-raw-map (kbd "M-n") (lambda () (interactive) (term-send-raw-string "\en")))
  (define-key term-raw-map (kbd "M-,") 'term-send-input)
  (define-key term-raw-map (kbd "C-c y") 'term-paste)
  (define-key term-raw-map (kbd "C-S-y") 'term-paste)
  (define-key term-raw-map (kbd "C-h") nil) ; unbind C-h
  (define-key term-raw-map (kbd "M-x") nil) ; unbind M-x
  (define-key term-raw-map (kbd "C-7") 'my-term-toggle-char-line-mode)
  (define-key term-mode-map (kbd "C-7") 'my-term-toggle-char-line-mode))
(add-hook 'term-mode-hook 'my-term-setup t)
#+END_SRC

I'd like to have the terminal respect the default keys of the shell as much as possible hence I remap the non-standard bindings to the defaults. Furthermore I want to switch between Emacs-style navigation (term-line-mode) and raw terminal input (term-char-mode) quickly.

*** uniqify

#+BEGIN_QUOTE
Unique buffer names dependent on file name
#+END_QUOTE

#+BEGIN_SRC emacs-lisp
(require 'uniquify)
(setq uniquify-buffer-name-style 'forward)
(setq uniquify-min-dir-content 2)
#+END_SRC

*** vlf
#+BEGIN_QUOTE
Emacs minor mode that allows viewing, editing, searching and comparing large files in batches. Batch size can be adjusted on the fly and bounds the memory that is to be used for operations on the file. This way multiple large files can be instantly and simultaneously accessed without swapping and degraded performance.
#+END_QUOTE

Github: https://github.com/m00natic/vlfi

#+BEGIN_SRC emacs-lisp
(quelpa '(vlf :repo "m00natic/vlfi" :fetcher github :old-names (vlfi)))
(setq vlf-application 'dont-ask)        ; just do it
(setq vlf-batch-size 8192)              ; a bit more text per batch please
(require 'vlf-integrate)                ; just do it for real
#+END_SRC

*** web-mode

#+BEGIN_QUOTE
web-mode.el is an autonomous emacs major-mode for editing web templates:
HTML documents embedding parts (CSS / JavaScript) and blocks (client/server side)
#+END_QUOTE

http://web-mode.org/web-mode.png

Homepage: http://web-mode.org/
Github: https://github.com/fxbois/web-mode

#+BEGIN_SRC emacs-lisp
(quelpa '(web-mode :repo "fxbois/web-mode" :fetcher github))
(add-to-list 'auto-mode-alist '("\\.html?\\'" . web-mode))
#+END_SRC

Enable web-mode for html buffers. Disable font-locking in web-mode because it's conflicting with other modes that do font-locking.

*** w3m

An Emacs client for the command line web-browser =w3m=

#+BEGIN_SRC emacs-lisp
(when (require 'w3m nil t)
  (setq
   w3m-use-favicon nil
   w3m-default-display-inline-images t
   w3m-search-word-at-point nil
   w3m-use-cookies t
   w3m-home-page "http://en.wikipedia.org/"
   w3m-cookie-accept-bad-cookies t
   w3m-session-crash-recovery nil)
  (add-hook 'w3m-mode-hook
            (function (lambda ()
                        (set-face-foreground 'w3m-anchor-face "LightSalmon")
                        (set-face-foreground 'w3m-arrived-anchor-face "LightGoldenrod")
                        ;;(set-face-background 'w3m-image-anchor "black")
                        (load "w3m-lnum")
                        (defun w3m-go-to-linknum ()
                          "Turn on link numbers and ask for one to go to."
                          (interactive)
                          (let ((active w3m-lnum-mode))
                            (when (not active) (w3m-lnum-mode))
                            (unwind-protect
                                (w3m-move-numbered-anchor (read-number "Anchor number: "))
                              (when (not active) (w3m-lnum-mode))))
                          (w3m-view-this-url)
                          )
                        (define-key w3m-mode-map "f" 'w3m-go-to-linknum)
                        (define-key w3m-mode-map "L" 'w3m-lnum-mode)
                        (define-key w3m-mode-map "o" 'w3m-previous-anchor)
                        (define-key w3m-mode-map "i" 'w3m-next-anchor)
                        (define-key w3m-mode-map "w" 'w3m-search-new-session)
                        (define-key w3m-mode-map "p" 'w3m-previous-buffer)
                        (define-key w3m-mode-map "n" 'w3m-next-buffer)
                        (define-key w3m-mode-map "z" 'w3m-delete-buffer)
                        (define-key w3m-mode-map "O" 'w3m-goto-new-session-url)
                        )))
  )
#+END_SRC

*** evil

#+BEGIN_SRC emacs-lisp
(setq evil-want-C-u-scroll t)

(quelpa 'evil)
(require 'evil)
(evil-mode 1)

(evil-set-initial-state 'magit-log-edit-mode 'emacs)
(evil-set-initial-state 'nav-mode 'emacs)
(evil-set-initial-state 'grep-mode 'emacs)
(evil-set-initial-state 'helm-mode 'emacs)
(evil-set-initial-state 'helm-command 'emacs)
#+END_SRC

** end

*** my-keys-minor-mode

#+BEGIN_SRC emacs-lisp
(define-minor-mode my-keys-minor-mode
  "A minor mode so that my key settings override annoying major modes."
  t " K" 'my-keys-minor-mode-map)
(my-keys-minor-mode 1)
#+END_SRC

#+HTML: <script type="text/javascript" src="//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
#+HTML: <script type="text/javascript" src="/stuff/js/bootstrap.min.js"></script>
